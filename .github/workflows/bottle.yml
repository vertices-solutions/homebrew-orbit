name: Build bottles

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version or tag (e.g., 0.2.0 or v0.2.0)"
        required: false
        type: string

env:
  HOMEBREW_NO_AUTO_UPDATE: "1"

jobs:
  bottle:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [macos-14, macos-15, macos-26, ubuntu-22.04]

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure versioned formula (optional bump)
        env:
          VERSION_INPUT: ${{ inputs.version }}
        run: |
          python3 - <<'PY'
          import hashlib
          import os
          import re
          import sys
          import urllib.request

          def series_of(version):
              parts = version.split(".")
              if len(parts) < 2:
                  raise ValueError(f"Version '{version}' does not have major.minor")
              return f"{parts[0]}.{parts[1]}"

          def class_name(series):
              return "OrbitAT" + series.replace(".", "")

          def parse_version(formula_text):
              patterns = (
                  r'^\s*version\s+"([^"]+)"',
                  r'^\s*url\s+"[^"]*/v?([^"/]+)\.tar\.gz"',
              )
              for pattern in patterns:
                  match = re.search(pattern, formula_text, flags=re.M)
                  if match:
                      return match.group(1)
              raise SystemExit("Could not determine version from Formula/orbit.rb")

          version_input = os.environ.get("VERSION_INPUT", "").strip()

          path = "Formula/orbit.rb"
          with open(path, "r", encoding="utf-8") as fh:
              text = fh.read()

          if version_input:
              new_version = version_input.lstrip("v")
              tag = f"v{new_version}"
              url = f"https://github.com/vertices-solutions/orbit/archive/refs/tags/{tag}.tar.gz"

              sha256 = hashlib.sha256()
              with urllib.request.urlopen(url) as resp:
                  while True:
                      chunk = resp.read(1024 * 1024)
                      if not chunk:
                          break
                      sha256.update(chunk)
              digest = sha256.hexdigest()

              text = re.sub(r'^(\s*url\s+\")[^\"]+\"', rf'\g<1>{url}"', text, flags=re.M)
              text = re.sub(r'^(\s*sha256\s+\")[^\"]+\"', rf'\g<1>{digest}"', text, flags=re.M)
              text = re.sub(r'\n\s*bottle do\n(?:.|\n)*?\n\s*end\n', '\n', text, count=1)

              with open(path, "w", encoding="utf-8") as fh:
                  fh.write(text)

              print(f"Updated Formula/orbit.rb to {new_version} (sha256 {digest})")
          else:
              new_version = parse_version(text)

          new_series = series_of(new_version)
          env_path = os.environ.get("GITHUB_ENV")
          if env_path:
              with open(env_path, "a", encoding="utf-8") as fh:
                  fh.write(f"VERSION={new_version}\n")
                  fh.write(f"SERIES={new_series}\n")

          versioned_path = f"Formula/orbit@{new_series}.rb"
          versioned_text = re.sub(
              r'\n\s*bottle do\n(?:.|\n)*?\n\s*end\n',
              '\n',
              text,
              count=1,
          )
          versioned_text, count = re.subn(
              r'^\s*class\s+\w+\s+<\s+Formula\s*$',
              f"class {class_name(new_series)} < Formula",
              versioned_text,
              flags=re.M,
          )
          if count != 1:
              raise SystemExit("Could not update class name for versioned formula")
          if not re.search(r'^\s*keg_only\s+:versioned_formula\s*$', versioned_text, flags=re.M):
              versioned_text, count = re.subn(
                  r'^(\s*license\s+"[^"]+")',
                  r'\1\n\n  keg_only :versioned_formula',
                  versioned_text,
                  flags=re.M,
                  count=1,
              )
              if count != 1:
                  raise SystemExit("Could not insert keg_only for versioned formula")
          with open(versioned_path, "w", encoding="utf-8") as fh:
              fh.write(versioned_text)
          print(f"Updated {versioned_path} to {new_version} (series {new_series})")
          PY

      - name: Set up Homebrew (macOS)
        if: runner.os == 'macOS'
        run: |
          if [ -x /opt/homebrew/bin/brew ]; then
            echo "/opt/homebrew/bin" >> "$GITHUB_PATH"
          fi
          if [ -x /usr/local/bin/brew ]; then
            echo "/usr/local/bin" >> "$GITHUB_PATH"
          fi

      - name: Install Homebrew (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential curl file git
          NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          echo "/home/linuxbrew/.linuxbrew/bin" >> "$GITHUB_PATH"
          echo "/home/linuxbrew/.linuxbrew/sbin" >> "$GITHUB_PATH"

      - name: Compute tap + formula name
        run: |
          repo="${GITHUB_REPOSITORY#*/}"
          tap_repo="${repo#homebrew-}"
          tap="${GITHUB_REPOSITORY_OWNER}/${tap_repo}"
          echo "TAP_REPO=${tap_repo}" >> "$GITHUB_ENV"
          echo "TAP=${tap}" >> "$GITHUB_ENV"
          echo "FORMULA=${tap}/orbit" >> "$GITHUB_ENV"
          if [ -n "${SERIES}" ]; then
            echo "FORMULA_VERSIONED=${tap}/orbit@${SERIES}" >> "$GITHUB_ENV"
            echo "FORMULA_VERSIONED_PATH=Formula/orbit@${SERIES}.rb" >> "$GITHUB_ENV"
          fi

      - name: Tap this repository
        run: |
          ruby -c "${GITHUB_WORKSPACE}/Formula/orbit.rb"
          brew_repo="$(brew --repository)"
          tap_dir="${brew_repo}/Library/Taps/${GITHUB_REPOSITORY_OWNER}/homebrew-${TAP_REPO}"
          brew untap --force "${TAP}" 2>/dev/null || true
          case "${tap_dir}" in
            "${brew_repo}"/Library/Taps/*) rm -rf "${tap_dir}" ;;
            *) echo "Refusing to remove unexpected tap dir: ${tap_dir}" ; exit 1 ;;
          esac
          brew tap "${TAP}" "${GITHUB_WORKSPACE}"
          tap_path="$(brew --repo "${TAP}")"
          src="${GITHUB_WORKSPACE}/Formula/orbit.rb"
          dst="${tap_path}/Formula/orbit.rb"
          SRC="${src}" DST="${dst}" python3 - <<'PY'
          import os, shutil
          src = os.environ["SRC"]
          dst = os.environ["DST"]
          if os.path.realpath(src) != os.path.realpath(dst):
              shutil.copyfile(src, dst)
          PY
          ruby -c "${dst}"
          if [ -n "${FORMULA_VERSIONED_PATH}" ] && [ -f "${GITHUB_WORKSPACE}/${FORMULA_VERSIONED_PATH}" ]; then
            src="${GITHUB_WORKSPACE}/${FORMULA_VERSIONED_PATH}"
            dst="${tap_path}/${FORMULA_VERSIONED_PATH}"
            SRC="${src}" DST="${dst}" python3 - <<'PY'
          import os, shutil
          src = os.environ["SRC"]
          dst = os.environ["DST"]
          os.makedirs(os.path.dirname(dst), exist_ok=True)
          if os.path.realpath(src) != os.path.realpath(dst):
              shutil.copyfile(src, dst)
          PY
            ruby -c "${dst}"
            git -C "${tap_path}" add "${FORMULA_VERSIONED_PATH}"
          fi

      - name: Compute version + root_url
        id: meta
        run: |
          version="$(brew info --json=v2 "${FORMULA}" | python3 -c 'import json, sys; data=json.load(sys.stdin); print(data["formulae"][0]["versions"]["stable"])')"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "root_url=https://github.com/${GITHUB_REPOSITORY}/releases/download/orbit-${version}" >> "$GITHUB_OUTPUT"


      - name: Build bottle
        run: |
          brew install --build-bottle "${FORMULA}"
          brew bottle --no-rebuild --json --root-url "${{ steps.meta.outputs.root_url }}" "${FORMULA}"
          if [ -n "${FORMULA_VERSIONED}" ]; then
            brew install --build-bottle "${FORMULA_VERSIONED}"
            brew bottle --no-rebuild --json --root-url "${{ steps.meta.outputs.root_url }}" "${FORMULA_VERSIONED}"
          fi

          # Rename local bottle tarballs to the upload filename Homebrew expects
          python3 - <<'PY'
          import glob, json, os

          def iter_bottle_infos(data):
              # Newer `brew bottle --json` format: {formula => {"bottle": {"tags": {tag: info}}}}
              if isinstance(data, dict) and "formulae" in data:
                  for f in data.get("formulae", []):
                      bottles = f.get("bottles", {}) or {}
                      for info in bottles.values():
                          yield info
                  return
              if isinstance(data, dict):
                  for entry in data.values():
                      if not isinstance(entry, dict):
                          continue
                      bottle = entry.get("bottle", {}) or {}
                      tags = bottle.get("tags", {}) or {}
                      for info in tags.values():
                          yield info

          for jf in glob.glob("*.bottle.json"):
              with open(jf, "r", encoding="utf-8") as fh:
                  data = json.load(fh)
              for info in iter_bottle_infos(data):
                  local = info.get("local_filename")
                  want = info.get("filename")
                  if not local or not want:
                      continue
                  if local != want and os.path.exists(local):
                      print(f"Renaming {local} -> {want}")
                      os.rename(local, want)
          PY

          mkdir -p dist
          mv *.bottle*.tar.gz dist/
          mv *.bottle.json dist/

      - uses: actions/upload-artifact@v4
        with:
          name: bottles-${{ matrix.os }}
          path: dist/*
  publish:
    runs-on: ubuntu-22.04
    needs: bottle
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure versioned formula (optional bump)
        env:
          VERSION_INPUT: ${{ inputs.version }}
        run: |
          python3 - <<'PY'
          import hashlib
          import os
          import re
          import sys
          import urllib.request

          def series_of(version):
              parts = version.split(".")
              if len(parts) < 2:
                  raise ValueError(f"Version '{version}' does not have major.minor")
              return f"{parts[0]}.{parts[1]}"

          def class_name(series):
              return "OrbitAT" + series.replace(".", "")

          def parse_version(formula_text):
              patterns = (
                  r'^\s*version\s+"([^"]+)"',
                  r'^\s*url\s+"[^"]*/v?([^"/]+)\.tar\.gz"',
              )
              for pattern in patterns:
                  match = re.search(pattern, formula_text, flags=re.M)
                  if match:
                      return match.group(1)
              raise SystemExit("Could not determine version from Formula/orbit.rb")

          version_input = os.environ.get("VERSION_INPUT", "").strip()

          path = "Formula/orbit.rb"
          with open(path, "r", encoding="utf-8") as fh:
              text = fh.read()

          if version_input:
              new_version = version_input.lstrip("v")
              tag = f"v{new_version}"
              url = f"https://github.com/vertices-solutions/orbit/archive/refs/tags/{tag}.tar.gz"

              sha256 = hashlib.sha256()
              with urllib.request.urlopen(url) as resp:
                  while True:
                      chunk = resp.read(1024 * 1024)
                      if not chunk:
                          break
                      sha256.update(chunk)
              digest = sha256.hexdigest()

              text = re.sub(r'^(\s*url\s+\")[^\"]+\"', rf'\g<1>{url}"', text, flags=re.M)
              text = re.sub(r'^(\s*sha256\s+\")[^\"]+\"', rf'\g<1>{digest}"', text, flags=re.M)
              text = re.sub(r'\n\s*bottle do\n(?:.|\n)*?\n\s*end\n', '\n', text, count=1)

              with open(path, "w", encoding="utf-8") as fh:
                  fh.write(text)

              print(f"Updated Formula/orbit.rb to {new_version} (sha256 {digest})")
          else:
              new_version = parse_version(text)

          new_series = series_of(new_version)
          env_path = os.environ.get("GITHUB_ENV")
          if env_path:
              with open(env_path, "a", encoding="utf-8") as fh:
                  fh.write(f"VERSION={new_version}\n")
                  fh.write(f"SERIES={new_series}\n")

          versioned_path = f"Formula/orbit@{new_series}.rb"
          versioned_text = re.sub(
              r'\n\s*bottle do\n(?:.|\n)*?\n\s*end\n',
              '\n',
              text,
              count=1,
          )
          versioned_text, count = re.subn(
              r'^\s*class\s+\w+\s+<\s+Formula\s*$',
              f"class {class_name(new_series)} < Formula",
              versioned_text,
              flags=re.M,
          )
          if count != 1:
              raise SystemExit("Could not update class name for versioned formula")
          if not re.search(r'^\s*keg_only\s+:versioned_formula\s*$', versioned_text, flags=re.M):
              versioned_text, count = re.subn(
                  r'^(\s*license\s+"[^"]+")',
                  r'\1\n\n  keg_only :versioned_formula',
                  versioned_text,
                  flags=re.M,
                  count=1,
              )
              if count != 1:
                  raise SystemExit("Could not insert keg_only for versioned formula")
          with open(versioned_path, "w", encoding="utf-8") as fh:
              fh.write(versioned_text)
          print(f"Updated {versioned_path} to {new_version} (series {new_series})")
          PY

      - name: Install Homebrew (Linux)
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential curl file git
          NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          echo "/home/linuxbrew/.linuxbrew/bin" >> "$GITHUB_PATH"
          echo "/home/linuxbrew/.linuxbrew/sbin" >> "$GITHUB_PATH"

      - name: Compute tap + formula name
        run: |
          repo="${GITHUB_REPOSITORY#*/}"
          tap_repo="${repo#homebrew-}"
          tap="${GITHUB_REPOSITORY_OWNER}/${tap_repo}"
          echo "TAP_REPO=${tap_repo}" >> "$GITHUB_ENV"
          echo "TAP=${tap}" >> "$GITHUB_ENV"
          echo "FORMULA=${tap}/orbit" >> "$GITHUB_ENV"
          if [ -n "${SERIES}" ]; then
            echo "FORMULA_VERSIONED=${tap}/orbit@${SERIES}" >> "$GITHUB_ENV"
            echo "FORMULA_VERSIONED_PATH=Formula/orbit@${SERIES}.rb" >> "$GITHUB_ENV"
          fi

      - name: Tap this repository
        run: |
          ruby -c "${GITHUB_WORKSPACE}/Formula/orbit.rb"
          brew_repo="$(brew --repository)"
          tap_dir="${brew_repo}/Library/Taps/${GITHUB_REPOSITORY_OWNER}/homebrew-${TAP_REPO}"
          brew untap --force "${TAP}" 2>/dev/null || true
          case "${tap_dir}" in
            "${brew_repo}"/Library/Taps/*) rm -rf "${tap_dir}" ;;
            *) echo "Refusing to remove unexpected tap dir: ${tap_dir}" ; exit 1 ;;
          esac
          brew tap "${TAP}" "${GITHUB_WORKSPACE}"
          tap_path="$(brew --repo "${TAP}")"
          src="${GITHUB_WORKSPACE}/Formula/orbit.rb"
          dst="${tap_path}/Formula/orbit.rb"
          SRC="${src}" DST="${dst}" python3 - <<'PY'
          import os, shutil
          src = os.environ["SRC"]
          dst = os.environ["DST"]
          if os.path.realpath(src) != os.path.realpath(dst):
              shutil.copyfile(src, dst)
          PY
          ruby -c "${dst}"
          if [ -n "${FORMULA_VERSIONED_PATH}" ] && [ -f "${GITHUB_WORKSPACE}/${FORMULA_VERSIONED_PATH}" ]; then
            src="${GITHUB_WORKSPACE}/${FORMULA_VERSIONED_PATH}"
            dst="${tap_path}/${FORMULA_VERSIONED_PATH}"
            SRC="${src}" DST="${dst}" python3 - <<'PY'
          import os, shutil
          src = os.environ["SRC"]
          dst = os.environ["DST"]
          os.makedirs(os.path.dirname(dst), exist_ok=True)
          if os.path.realpath(src) != os.path.realpath(dst):
              shutil.copyfile(src, dst)
          PY
            ruby -c "${dst}"
            git -C "${tap_path}" add "${FORMULA_VERSIONED_PATH}"
          fi

      - uses: actions/download-artifact@v4
        with:
          pattern: bottles-*
          path: dist
          merge-multiple: true

      - name: Compute version + root_url
        id: meta
        run: |
          version="$(brew info --json=v2 "${FORMULA}" | python3 -c 'import json, sys; data=json.load(sys.stdin); print(data["formulae"][0]["versions"]["stable"])')"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "root_url=https://github.com/${GITHUB_REPOSITORY}/releases/download/orbit-${version}" >> "$GITHUB_OUTPUT"

      - name: Configure git identity (for brew + commits)
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          echo "HOMEBREW_GIT_NAME=github-actions[bot]" >> "$GITHUB_ENV"
          echo "HOMEBREW_GIT_EMAIL=github-actions[bot]@users.noreply.github.com" >> "$GITHUB_ENV"

      - name: Merge bottle metadata into formula (and copy back)
        run: |
          # Merge ALL JSONs into the tapped formula and write bottle stanza
          mapfile -d '' json_files < <(find dist -type f -name '*.bottle.json' -print0)
          if [ "${#json_files[@]}" -eq 0 ]; then
            echo "No bottle JSON files found under ./dist"
            find dist -maxdepth 4 -type f -print
            exit 1
          fi
          brew bottle --merge --write --root-url "${{ steps.meta.outputs.root_url }}" "${json_files[@]}"

          # Copy the formula from the tap checkout back into this repo workspace
          tap_path="$(brew --repo "${TAP}")"
          src="${tap_path}/Formula/orbit.rb"
          dst="${GITHUB_WORKSPACE}/Formula/orbit.rb"
          SRC="${src}" DST="${dst}" python3 - <<'PY'
          import os, shutil
          src = os.environ["SRC"]
          dst = os.environ["DST"]
          # Make sure the destination dir exists
          os.makedirs(os.path.dirname(dst), exist_ok=True)
          if os.path.realpath(src) != os.path.realpath(dst):
              shutil.copyfile(src, dst)
          PY
          if [ -n "${FORMULA_VERSIONED_PATH}" ] && [ -f "${tap_path}/${FORMULA_VERSIONED_PATH}" ]; then
            src="${tap_path}/${FORMULA_VERSIONED_PATH}"
            dst="${GITHUB_WORKSPACE}/${FORMULA_VERSIONED_PATH}"
            SRC="${src}" DST="${dst}" python3 - <<'PY'
          import os, shutil
          src = os.environ["SRC"]
          dst = os.environ["DST"]
          os.makedirs(os.path.dirname(dst), exist_ok=True)
          if os.path.realpath(src) != os.path.realpath(dst):
              shutil.copyfile(src, dst)
          PY
          fi

          # Hard fail if bottle stanza wasn't written
          grep -n "^[[:space:]]*bottle do" "${GITHUB_WORKSPACE}/Formula/orbit.rb"
          if [ -n "${FORMULA_VERSIONED_PATH}" ] && [ -f "${GITHUB_WORKSPACE}/${FORMULA_VERSIONED_PATH}" ]; then
            grep -n "^[[:space:]]*bottle do" "${GITHUB_WORKSPACE}/${FORMULA_VERSIONED_PATH}"
          fi

      - name: Commit formula updates (bottle stanza)
        run: |
          git add Formula/orbit.rb
          if ls Formula/orbit@*.rb >/dev/null 2>&1; then
            git add Formula/orbit@*.rb
          fi
          if ! git diff --cached --quiet; then
            git commit -m "Add bottle for orbit ${{ steps.meta.outputs.version }}"
          fi
          if [[ "${GITHUB_REF}" == refs/heads/* ]]; then
            branch="${GITHUB_REF#refs/heads/}"
            git push origin "HEAD:${branch}"
          fi

      - name: Create release + upload bottles
        uses: softprops/action-gh-release@v2
        with:
          tag_name: orbit-${{ steps.meta.outputs.version }}
          name: "orbit ${{ steps.meta.outputs.version }} bottles"
          files: dist/**/*.bottle*.tar.gz
